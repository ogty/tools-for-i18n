#!/usr/bin/env python3

from io import StringIO
import json
import os
import re
import sys
from typing import Dict, List

import yaml

from settings import (
    INDENT,
    PARSER,
    HELP_MESSAGE,
    CHARACTER_CODE,
    TABLE_TEMPLATE,
    EMPTY_DATA_NAME,
    EXPORT_FILE_NAME,
)


class LanguageSegmenter:
    """Segment translation files by language

    Variables:
        base_data              (dict): Base translation data
        base_language           (str): Base language
        segmented_data         (dict): Segmented translation data
        breadcrumb_list        (list): Breadcrumb list
        path_and_element_data  (list): Path and element data
    """
    base_data = {}
    base_language = ''
    segmented_data = {}
    breadcrumb_list = []
    path_and_element_data = []

    def __init__(self, languages: List[str], base_language: str, import_file_name: str) -> None:
        """Initialization handles file loading and segmenting

        Args:
            import_file_name            (str): Used to read yaml file
            languages             (List[str]): Selection of the language described in the yaml file
            base_language     (str, optional): Most reliable language. Defaults to None.
        """
        self.languages = languages
        self.base_language = base_language
        LanguageSegmenter.base_language = self.base_language

        # Reads and assigns translation files
        with open(import_file_name, 'r', encoding=CHARACTER_CODE) as translation_file:
            LanguageSegmenter.base_data = yaml.safe_load(translation_file)

        # Segment the translation data from the given Languages into their respective languages
        [self.Processer(language) for language in self.languages]

        # Also create a breadcrumb list from the translation data
        self.BreadcrumbListGenerator()

    def write(self, path: str) -> None:
        """Output internationalization-compliant files.

        Args:
            path  (str): Path to the location to be created
        """
        for language in self.languages:
            locales_path = os.path.join(path, language)
            os.makedirs(locales_path, exist_ok=True)
            with open(os.path.join(locales_path, EXPORT_FILE_NAME), 'w') as translation_file:
                json.dump(
                    fp=translation_file,
                    obj=LanguageSegmenter.segmented_data[language],
                    indent=INDENT,
                    ensure_ascii=False,
                )

    def reverse_generation(self, file_name: str = None, language: str = None) -> None:
        """Method to generate a yaml file from data in json format

        Args:
            file_name  (str, optional): File name to output. Defaults to None.
            language   (str, optional): Arguments for converting "empty" to the specified language.
                                        Defaults to None
        """
        result = ''  # Finally, a string in yaml format is stored.
        before = []  # Stores the path of the previous data.

        path_and_element_data = LanguageSegmenter.path_and_element_data
        for string_breadcrumb_list, element_value in path_and_element_data:
            # When the argument language is specified, replace empty with that language
            if language is not None:
                lowercase_empty_data_name = EMPTY_DATA_NAME.lower()
                string_breadcrumb_list = re.sub(
                    rf"{lowercase_empty_data_name}$",
                    language,
                    string_breadcrumb_list
                )

            # Obtain the same point as "before".
            breadcrumb_list = string_breadcrumb_list.split('.')
            same_paths = list(set(before) & set(breadcrumb_list))
            same_path_indexes = [breadcrumb_list.index(same_path) for same_path in same_paths]

            # Generate yaml data string from path and element data
            for index, path in enumerate(breadcrumb_list):
                # If it is the same place as "before", move to the next element.
                if index in same_path_indexes:
                    continue

                string_indent = index * (' ' * INDENT)

                # If at the end of the path, store the element at the same time
                if (len(breadcrumb_list) - 1) == index:
                    element_value = element_value.replace('\n', "\n%s" % string_indent)
                    result += "%s%s: %s\n" % (string_indent, path, element_value)
                    continue

                # If not the end of the path, store only the name of the path
                result += "%s%s:\n" % (string_indent, path)

            before = breadcrumb_list  # Update the before data

        print(result)
        if file_name is not None:
            with open(file_name, 'w', encoding=CHARACTER_CODE) as yaml_translation_file:
                yaml_translation_file.write(result)

    def get_value(self, data: Dict[str, any], path: str, language: str) -> any:
        """Function to get data from a string connected by dots

        Args:
            data      (Dict[str, any]): Data traced by the path
            path                 (str): Paths connected by dots
            language             (str): Languages to be retrieved from data

        Returns:
            any: It is the type of data for the translation.
        """
        for key in path.split('.'):
            data = data[key]
        return data[language]

    def output_table(self, empty: bool, languages: List[str], file_name: str = None) -> None:
        """Outputs a translation table

        Args:
            languages       (List[str]): Selecting the language of output
            file_name   (str, optional): File name to output. Defaults to None.
            empty      (bool, optional): Whether to display empty data as well. Defaults to False.
        """
        if empty:
            languages.append(EMPTY_DATA_NAME)

        io = StringIO()
        column_string = "</td><td>".join(list(map(lambda x: x.upper(), languages)))
        template = TABLE_TEMPLATE.replace("---", column_string, 1)

        html_data_string = ''
        for path in LanguageSegmenter.breadcrumb_list:
            html_data_string += "<tr></tr><tr><td>\n\n```\n%s\n```\n\n</td>" % path

            for language in languages:
                data = self.get_value(
                    path=path,
                    data=LanguageSegmenter.base_data,
                    language=self.base_language if language == EMPTY_DATA_NAME else language,
                )
                # Convert and format Python objects to json format data
                json.dump(obj=data, fp=io, indent=INDENT, ensure_ascii=False)
                string_data = io.getvalue()  # Get converted json format data

                # Generate data with empty element names in the base language data
                if language == EMPTY_DATA_NAME:
                    if not isinstance(data, str):
                        splited_string_data = string_data.split('\n')
                        for line in splited_string_data:
                            match = re.search(r'"(.*)"', line)
                            if match is not None:
                                string_data = string_data.replace(match.group(1), '')
                    else:
                        match = re.search(r'"(.*)"', string_data)
                        if match is not None:
                            string_data = string_data.replace(match.group(1), '')

                # Stores breadcrumb lists and corresponding data
                path_and_data = ("%s.%s" % (path, language.lower()), string_data)
                LanguageSegmenter.path_and_element_data.append(path_and_data)

                html_data_string += "<td>\n\n```js\n%s\n```\n\n</td>" % string_data
                io.truncate(0)  # Reset data
                io.seek(0)      # Reset position

            html_data_string += "</tr>"

        result = template.replace("---", html_data_string)
        print(result)
        io.close()

        if file_name is not None:
            with open(file_name, 'w', encoding=CHARACTER_CODE) as html_file:
                html_file.write(result)

    class Processer:
        """Class containing recursive functions for language-specific segmenting"""

        def __init__(self, language: str):
            """Executed at initialization. Result reflects class variables of parent class.

            Args:
                language  (str): Specify a single language
            """
            self.language = language
            self.result = {}

            self.segmenter(LanguageSegmenter.base_data)
            LanguageSegmenter.segmented_data[self.language] = self.result

        def segmenter(self, translation_data: Dict[str, any]) -> Dict[str, any]:
            """Recursive functions for segmenting translation data

            Args:
                translation_data  (Dict[str, any]): key, value in value data

            Returns:
                Dict[str, any]: Elements of translation data
            """
            element = {}
            for key, value in translation_data.items():
                if self.language in value:
                    element[key] = value[self.language]
                    continue
                element[key] = self.segmenter(value)

            self.result = element
            return element

    class BreadcrumbListGenerator:
        """Class containing recursive functions for breadcrumb list creation"""

        def __init__(self) -> None:
            """Initialize and execute"""
            self.generate_breadcrumb_list(LanguageSegmenter.base_data)

        def generate_breadcrumb_list(self, data: Dict[str, any], parent: str = None) -> None:
            """Create breadcrumb list at initialization

            Args:
                data   (Dict[str, any]): key, value in value data
                parent  (str, optional): Route information up to now. Defaults to None.
            """
            for key, value in data.items():
                if LanguageSegmenter.base_language in value:
                    path = key if parent is None else "%s.%s" % (parent, key)
                    LanguageSegmenter.breadcrumb_list.append(path)
                    continue

                path = key if parent is None else "%s.%s" % (parent, key)
                self.generate_breadcrumb_list(value, parent=path)


if __name__ == "__main__":
    # TODO:
    # - [ ] Load config and make it available.
    # - [ ] Raises an error when there is a missing element
    # - [ ] Create reverse generation options
    # - [ ] empty...

    if sys.argv[1] == "--help" or sys.argv[1] == "-h":
        print(HELP_MESSAGE)
        sys.exit(0)

    args = PARSER.parse_args()

    if args.file is None:
        print("Please specify a translation file")
        sys.exit(1)

    if args.languages is None:
        print("Please specify languages to be segmented")
        sys.exit(1)

    # Create an instance of LanguageSegmenter
    base_language = args.languages[0] if args.base_language is None else args.base_language
    segmenter = LanguageSegmenter(
        languages=args.languages,
        base_language=base_language,
        import_file_name=args.file,
    )

    if args.output:
        segmenter.write(args.output)

    if args.table:
        segmenter.output_table(
            empty=args.empty,
            languages=args.languages,
            file_name=None if args.file_name is None else args.file_name,
        )

    if args.reverse:
        segmenter.reverse_generation(
            language="fr",
            file_name="./sample.yaml",
        )
