#!/usr/bin/env python3

import argparse
from io import StringIO
import json
import os
import sys
from typing import Dict, List

import yaml

from settings import (
    EXPORT_FILE_NAME,
    TABLE_TEMPLATE,
    HELP_MESSAGE,
)


class LanguageSegmenter:
    """Segment translation files by language

    Variables:
        base_data (dict): Base translation data
        base_language (str): Base language
        segmented_data (dict): Segmented translation data
        breadcrumb_list (list): Breadcrumb list
    """

    base_data = {}

    base_language = ""

    segmented_data = {}

    breadcrumb_list = []

    def __init__(self, import_file_name: str, languages: List[str], base_language: str) -> None:
        """Initialization handles file loading and segmenting

        Args:
            import_file_name (str): Used to read yaml file
            languages (List[str]): Selection of the language described in the yaml file
            base_language (str, optional): Most reliable language. Defaults to None.
        """
        self.languages = languages
        LanguageSegmenter.base_language = base_language
        with open(import_file_name, "r", encoding="utf-8") as f:
            LanguageSegmenter.base_data = yaml.safe_load(f)

        [self.Processer(language) for language in self.languages]
        self.BreadcrumbListGenerator()

    def write(self, path: str) -> None:
        """Output internationalization-compliant files.

        Args:
            path (str): Path to the location to be created
        """
        for language in self.languages:
            locales_path = os.path.join(path, language)
            os.makedirs(locales_path, exist_ok=True)
            with open(os.path.join(locales_path, EXPORT_FILE_NAME), "w") as f:
                json.dump(
                    fp=f,
                    obj=LanguageSegmenter.segmented_data[language],
                    indent=4,
                    ensure_ascii=False,
                )

    def get_value(self, path: str, data: Dict[str, any], language: str) -> any:
        """Function to get data from a string connected by dots

        Args:
            path (str): Paths connected by dots
            data (Dict[str, any]): Data traced by the path
            language (str): Languages to be retrieved from data

        Returns:
            any: It is the type of data for the translation.
        """
        for key in path.split("."):
            data = data[key]
        return data[language]
    
    def output_table(self, languages: List[str], file_name: str = None) -> None:
        """Outputs a translation table

        Args:
            languages (List[str]): Selecting the language of output
        """
        io = StringIO()

        column_string = "</td><td>".join(list(map(lambda x: x.upper(), languages)))
        template = TABLE_TEMPLATE.replace("---", column_string, 1)

        html_data_string = ""
        for path in LanguageSegmenter.breadcrumb_list:
            html_data_string += f"<tr></tr><tr><td>\n\n```\n{path}\n```\n\n</td>"
            for language in languages:
                data = self.get_value(path, LanguageSegmenter.base_data, language)
                json.dump(obj=data, fp=io, indent=4, ensure_ascii=False)
                html_data_string += f"<td>\n\n```js\n{io.getvalue()}\n```\n\n</td>"
                io.truncate(0)
                io.seek(0)

            html_data_string += "</tr>"

        result = template.replace("---", html_data_string)
        print(result)
        io.close()

        if file_name is not None:
            with open(file_name, "w", encoding="utf-8") as f:
                f.write(result)

    class Processer:
        """
        Class containing recursive functions for language-specific segmenting
        """

        def __init__(self, language: str):
            """Executed at initialization. Result reflects class variables of parent class.

            Args:
                language (str): Specify a single language
            """
            self.language = language
            self.result = {}

            self.segmenter(LanguageSegmenter.base_data)
            LanguageSegmenter.segmented_data[self.language] = self.result

        def segmenter(self, translation_data: Dict[str, any]) -> Dict[str, any]:
            """Recursive functions for segmenting translation data

            Args:
                translation_data (Dict[str, any]): key, value in value data

            Returns:
                Dict[str, any]: Elements of translation data
            """
            element = {}
            for key, value in translation_data.items():
                if self.language in value:
                    element[key] = value[self.language]
                else:
                    element[key] = self.segmenter(value)

            self.result = element
            return element

    class BreadcrumbListGenerator:
        """
        Class containing recursive functions for breadcrumb list creation
        """

        def __init__(self) -> None:
            """
            _sumInitialize and executemary_
            """
            self.generate_breadcrumb_list(LanguageSegmenter.base_data)

        def generate_breadcrumb_list(self, data: Dict[str, any], parent: str = None) -> None:
            """Create breadcrumb list at initialization

            Args:
                data (Dict[str, any]): key, value in value data
                parent (str, optional): Route information up to now. Defaults to None.
            """
            for key, value in data.items():
                if LanguageSegmenter.base_language in value:
                    LanguageSegmenter.breadcrumb_list.append(key if parent is None else f"{parent}.{key}")
                else:
                    path = key if parent is None else f"{parent}.{key}"
                    self.generate_breadcrumb_list(value, parent=path)


if __name__ == "__main__":
    if sys.argv[1] == "--help":
        print(HELP_MESSAGE)
        sys.exit(0)

    parser = argparse.ArgumentParser(description="Segment translation files by language")
    parser.add_argument("--file", "-f", type=str, help="Path to the translation file")
    parser.add_argument("--languages", "-l", type=str, nargs="+", help="Languages to be segmented")
    parser.add_argument("--base_language", "-b", type=str, help="Most reliable language")
    parser.add_argument("--output", "-o", type=str, help="Path to the output directory")
    parser.add_argument("--table", "-t", action="store_true", help="Output translation table")
    parser.add_argument("--file_name", "-n", type=str, help="Output file name")
    args = parser.parse_args()

    if args.file is None:
        print("Please specify a translation file")
        exit(1)

    if args.languages is None:
        print("Please specify languages to be segmented")
        exit(1)

    base_language = args.languages[0] if args.base_language is None else args.base_language
    segmenter = LanguageSegmenter(
        import_file_name=args.file,
        languages=args.languages,
        base_language=base_language,
    )
    segmenter.output_table(args.languages)

    if args.output:
        segmenter.write(args.output)

    if args.table:
        segmenter.output_table(
            languages=args.languages,
            file_name=None if args.file_name is None else args.file_name,
        )
